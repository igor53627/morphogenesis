\documentclass[11pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\geometry{margin=1in}

\input{macros}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  breaklines=true,
  frame=single,
  xleftmargin=1em,
  xrightmargin=1em,
  columns=fullflexible,
  keepspaces=true,
  upquote=true,
}

\title{\morph{}:\\2-Party DPF-PIR for Ethereum State}
\author{
Igor Barinov \\
Ethereum Foundation \\
\texttt{igor.barinov@ethereum.org}
}
\date{February 2026}

\begin{document}
\maketitle

\begin{abstract}
We present \morph{}, a 2-server Private Information Retrieval (PIR) protocol
based on Distributed Point Functions (DPF) for the Ethereum state.
The system allows a client to query the balance, nonce, bytecode, or storage
of any Ethereum address without revealing the target to the server.
A linearized Cuckoo hash table ($2^{32}$ domain, 85\% load factor,
2.15~billion rows) is stored in GPU VRAM and scanned via a fused
ChaCha8-DPF$\oplus$XOR CUDA kernel achieving 2,143~GB/s throughput and
32.1~ms latency on NVIDIA H100.
Epoch-Based Delta-PIR provides wait-free snapshot isolation for live updates
with $O(1)$ amortized cost.
An RPC adapter proxy implements 20+ Ethereum JSON-RPC methods privately,
serving as a drop-in replacement for standard providers.
Privacy is Information-Theoretic under the 2-server semi-honest model.
The production deployment path is the server plus RPC adapter; the browser
WASM gateway remains experimental, and end-to-end verifiable proofs are
currently iceboxed.
\end{abstract}

%------------------------------------------------------------------------------
\section{Overview}
\label{sec:overview}
%------------------------------------------------------------------------------

\morph{} is a \textbf{Private Information Retrieval} (PIR) protocol for
Ethereum state. A client queries the balance, nonce, code, or storage of
\emph{any} address without revealing the target to the server.

\paragraph{Key Properties.}
\begin{itemize}
  \item \textbf{Privacy:} Information-Theoretic (IT-PIR) via 2-server DPF.
  \item \textbf{Scale:} 2.15~billion rows (full Mainnet accounts + storage).
  \item \textbf{Latency:} 32.1~ms query time on H100 (subtree kernel),
        27.4~ms on B200.
  \item \textbf{Simplicity:} Each party runs on a single commodity GPU server.
\end{itemize}

\paragraph{Workspace.}
The implementation is organized as a Rust workspace with nine crates
(Table~\ref{tab:crates}).

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Crate} & \textbf{Role} \\
\midrule
\texttt{morphogen-core}        & Core types: DeltaBuffer, EpochSnapshot,
                                 GlobalState, Cuckoo hashing \\
\texttt{morphogen-dpf}         & DPF key trait and implementations
                                 (AES-based, fss-rs) \\
\texttt{morphogen-gpu-dpf}     & GPU-accelerated DPF using ChaCha8 PRG
                                 (CUDA) \\
\texttt{morphogen-storage}     & AlignedMatrix and ChunkedMatrix storage
                                 primitives \\
\texttt{morphogen-server}      & Scan kernel, HTTP/WebSocket server,
                                 benchmarks \\
\texttt{morphogen-client}      & PIR client with network layer, caching,
                                 and batch aggregation \\
\texttt{morphogen-wasm-gateway}& Browser EIP-1193 facade (experimental) \\
\texttt{morphogen-rpc-adapter} & JSON-RPC proxy: private methods via PIR,
                                 passthrough to upstream \\
\texttt{reth-adapter}          & Reth integration for mainnet snapshot ETL \\
\bottomrule
\end{tabular}
\caption{Workspace crate overview.}
\label{tab:crates}
\end{table}

%------------------------------------------------------------------------------
\section{Mathematical Formulation}
\label{sec:math}
%------------------------------------------------------------------------------

\subsection{Database Model}

Let $N$ denote the number of rows in the database. Each row is an $\ell$-bit
vector. We model the database as:
\[
D : [N] \to \{0,1\}^\ell
\]
where $[N] = \{0, 1, \ldots, N-1\}$.
In the Compact schema, $\ell = 256$ (32 bytes);
in the Storage Optimized48 schema, $\ell = 384$ (48 bytes).

\subsection{DPF Algebra}

We use a Distributed Point Function (\dpf{})~\cite{GI14} for the unit point
function $f_{\alpha}(x) = \mathbf{1}_{x = \alpha}$.

\begin{definition}[Distributed Point Function]
A \dpf{} scheme with domain $[N]$ consists of:
\begin{itemize}
  \item $\gen(1^\lambda, \alpha) \to (k_0, k_1)$: Generate key shares for
        target index $\alpha \in [N]$
  \item $\eval(k_b, x) \to \{0, 1\}$: Evaluate key share $b \in \{0,1\}$
        at index $x \in [N]$
\end{itemize}
satisfying:
\begin{itemize}
  \item \textbf{Correctness:}
        $\forall x \in [N]: \eval(k_0, x) \oplus \eval(k_1, x)
         = \mathbf{1}_{x = \alpha}$
  \item \textbf{Security:} Each $k_b$ is computationally indistinguishable
        from random, given only that share.
\end{itemize}
\end{definition}

\subsection{Server Accumulation}

Each server $b \in \{0, 1\}$ computes the XOR-accumulation over all rows,
masked by the DPF evaluation:
\[
R_b = \bigoplus_{x=0}^{N-1} \Big( D(x) \cdot \eval(k_b, x) \Big)
\]
where $D(x) \cdot \eval(k_b, x)$ denotes the $\ell$-bit row $D(x)$ if
$\eval(k_b, x) = 1$, and the zero vector otherwise.

The client reconstructs: $D(\alpha) = R_0 \oplus R_1$.

%------------------------------------------------------------------------------
\section{Data Model}
\label{sec:data-model}
%------------------------------------------------------------------------------

\subsection{Cuckoo Hash Table}

The database is a flattened, linearized Cuckoo hash table~\cite{PR04}
stored in GPU VRAM (Table~\ref{tab:cuckoo}).

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Parameter} & \textbf{Value} & \textbf{Notes} \\
\midrule
Domain          & $2^{32}$    & Covers 2.15B rows \\
Hash Functions  & 3           & Keyed SipHash \\
Load Factor     & 85\%        & Random-walk insertion minimizes stash \\
Tag Key         & 8 bytes     & $\texttt{keccak}(\textit{address} \|
                                \textit{slot})[0..8]$ for storage lookups \\
\bottomrule
\end{tabular}
\caption{Cuckoo hash table parameters.}
\label{tab:cuckoo}
\end{table}

\subsection{Row Schemas}

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Schema} & \textbf{Size} & \textbf{Layout} & \textbf{Use} \\
\midrule
Account Compact      & 32\,B  & Balance(16) $|$ Nonce(8) $|$ CodeID(4) $|$
                                Pad(4) & Account state \\
Storage Optimized48  & 48\,B  & Value(32) $|$ Tag(8) $|$ Pad(8)
                              & Storage slots \\
\bottomrule
\end{tabular}
\caption{Row schemas.}
\label{tab:schemas}
\end{table}

\subsection{DPF Key Types}

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Key} & \textbf{Size} & \textbf{Level} & \textbf{Use} \\
\midrule
\texttt{AesDpfKey}  & 25\,B                   & Row  & AES seed (16) +
                                                        target (8) +
                                                        correction (1) \\
\texttt{PageDpfKey} & $\sim$491\,B (25-bit)    & Page & fss-rs based,
                                                        chunked evaluation \\
\texttt{ChaChaKey}  & Variable                 & GPU  & ChaCha8 PRG for
                                                        CUDA fused kernel \\
\bottomrule
\end{tabular}
\caption{DPF key types.}
\label{tab:dpf-keys}
\end{table}

%------------------------------------------------------------------------------
\section{Query Protocol}
\label{sec:query}
%------------------------------------------------------------------------------

\subsection{Parallel Cuckoo Addressing}

To mitigate adaptive leakage, we employ \textbf{Parallel Retrieval}.
For target account~$A$ with candidate indices $h_1, h_2, h_3$:

\begin{enumerate}
  \item Client generates query batch $Q = \{k^{(1)}, k^{(2)}, k^{(3)}\}$.
  \item Server executes all 3 queries in a single linear pass.
  \item Client receives 3 payloads.
        Since the Cuckoo failure probability with stash size $s=256$ is
        negligible, we treat lookup failure as operationally zero.
\end{enumerate}

\paragraph{Random-Walk Cuckoo Insertion.}
3-way Cuckoo hashing with random-walk insertion achieves 85\% load factor
(vs 50\% with deterministic cycling).
Each key hashes to 3 candidate positions using independent keyed hash
functions. On collision, a random candidate (excluding the just-evicted
position) is selected for displacement.
\textbf{Result:} 78M accounts require only 92M rows
($1.18\times$ overhead) vs 156M rows ($2\times$) with naive Cuckoo.

\paragraph{Stash Handling via Delta-PIR.}
Items that cannot be placed during construction go to a stash.
At build-time, rehash with new seeds until the stash is empty.
At runtime, new accounts go to the Delta buffer at their $h_1$ position.
Clients only need the epoch's hash seeds and table size.

\subsection{Query Flow}

\begin{enumerate}
  \item \textbf{Addressing:} Client locally computes 3 indices
        $[h_1, h_2, h_3]$ using the Cuckoo seeds.
  \item \textbf{DPF Generation:} Client generates DPF keys for these
        indices.
  \item \textbf{Request:} Client sends keys to 2 non-colluding servers.
  \item \textbf{Scan:} Servers scan the entire matrix using a fused
        DPF-evaluation$\oplus$XOR kernel (backend-specific scan-step; CUDA/AVX
        implementation shown).
  \item \textbf{Response:} Servers return 3 encrypted blocks.
  \item \textbf{Reconstruction:} Client XORs the responses to recover the
        row.
\end{enumerate}

\subsection{Server API}

\paragraph{HTTP Endpoints.}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Method} & \textbf{Path} & \textbf{Description} \\
\midrule
GET  & \texttt{/health}          & Status, epoch\_id, block\_number \\
GET  & \texttt{/epoch}           & Epoch metadata (seeds, num\_rows,
                                   state\_root) \\
POST & \texttt{/query}           & Row-level PIR (3 DPF keys $\to$
                                   3 payloads) \\
POST & \texttt{/query/batch}     & Batch PIR (up to
                                   \texttt{MAX\_BATCH\_SIZE} queries) \\
POST & \texttt{/query/page}      & Page-level PIR (3 PageDPF keys $\to$
                                   3 pages) \\
POST & \texttt{/query/page/gpu}  & GPU page query (ChaChaKey) \\
\bottomrule
\end{tabular}
\caption{HTTP endpoints.}
\label{tab:http}
\end{table}

\paragraph{WebSocket Endpoints.}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Path} & \textbf{Description} \\
\midrule
\texttt{/ws/epoch} & Real-time epoch update stream \\
\texttt{/ws/query} & Single and batch queries over persistent connection \\
\bottomrule
\end{tabular}
\caption{WebSocket endpoints.}
\label{tab:ws}
\end{table}

\paragraph{Constants.}
$\texttt{MAX\_BATCH\_SIZE} = 32$, request body limit 64\,KB,
$\texttt{MAX\_CONCURRENT\_SCANS} = 32$.

\subsection{Code Resolution}

The 32-byte PIR row is too small for contract bytecode, so we use a sidecar:

\begin{enumerate}
  \item PIR query returns \texttt{Balance}, \texttt{Nonce}, and
        \texttt{CodeID}.
  \item Client resolves $\texttt{CodeID} \to \texttt{CodeHash}$ via a public
        Dictionary (HTTP Range Request).
  \item Client fetches bytecode from a public Content Addressable Storage
        (CAS/CDN).
\end{enumerate}

\subsection{Client Configuration}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Setting} & \textbf{Value} \\
\midrule
Cache capacity   & 4096 entries (LRU, epoch-invalidated) \\
Retries          & 2 attempts, 200\,ms exponential backoff \\
Connect timeout  & 5\,s \\
Request timeout  & 30\,s \\
Batch size       & 32 (matches server \texttt{MAX\_BATCH\_SIZE}) \\
\bottomrule
\end{tabular}
\caption{Client configuration.}
\label{tab:client}
\end{table}

Batch queries are auto-chunked at 32 with cache-aware partitioning:
cached entries are served locally, only misses go to the server.

%------------------------------------------------------------------------------
\section{RPC Adapter}
\label{sec:rpc}
%------------------------------------------------------------------------------

\subsection{Architecture}

\texttt{morphogen-rpc-adapter} is a JSON-RPC proxy on \texttt{:8545},
designed as a drop-in replacement for standard Ethereum RPC providers.
Compatible with MetaMask, Rabby, Frame, and any EIP-1193 wallet.

\subsection{Method Classification}

Table~\ref{tab:rpc} classifies how each JSON-RPC method is handled.

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}p{2.5cm}p{6.5cm}p{4cm}@{}}
\toprule
\textbf{Category} & \textbf{Methods} & \textbf{Mechanism} \\
\midrule
Private (PIR)     & \texttt{getBalance}, \texttt{getTransactionCount},
                    \texttt{getCode}, \texttt{getStorageAt}
                  & DPF query to PIR servers \\[3pt]
Private (EVM)     & \texttt{eth\_call}, \texttt{eth\_estimateGas}
                  & Local revm with \texttt{PirDatabase} \\[3pt]
Private (Cache)   & \texttt{eth\_getLogs},
                    \texttt{getTransactionByHash},
                    \texttt{getTransactionReceipt}
                  & Block cache (64 blocks) \\[3pt]
Private (Filters) & \texttt{newFilter}, \texttt{newBlockFilter},
                    \texttt{newPendingTransactionFilter},
                    \texttt{uninstallFilter},
                    \texttt{getFilterChanges},
                    \texttt{getFilterLogs}
                  & Local filter state \\[3pt]
Relay             & \texttt{eth\_sendRawTransaction}
                  & Flashbots Protect \\[3pt]
Passthrough       & \texttt{blockNumber}, \texttt{chainId},
                    \texttt{gasPrice}, \texttt{getBlockByNumber},
                    \texttt{getBlockByHash}, \texttt{feeHistory}, etc.
                  & Forwarded to upstream \\[3pt]
Dropped           & \texttt{getProof}, \texttt{sign},
                    \texttt{signTransaction}
                  & Rejected with error \\
\bottomrule
\end{tabular}
\caption{RPC method classification. All method names prefixed with
         \texttt{eth\_} unless noted.}
\label{tab:rpc}
\end{table}

\subsection{Access-List Prefetch}

For \texttt{eth\_call} and \texttt{eth\_estimateGas}, the adapter uses
EIP-2930 access lists to batch-prefetch state:

\begin{enumerate}
  \item Parse the transaction's \texttt{accessList} (or generate one via a
        dry-run).
  \item Batch PIR query all referenced accounts and storage slots.
  \item Warm the local cache before EVM execution.
\end{enumerate}

This reduces round-trips from $O(\text{state-accesses})$ to $O(1)$ batched
PIR queries.

\subsection{Block Cache}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Setting} & \textbf{Value} \\
\midrule
Cached blocks  & 64 (FIFO) \\
Poll interval  & 2\,s \\
Filter expiry  & 5\,min \\
\bottomrule
\end{tabular}
\caption{Block cache configuration.}
\label{tab:block-cache}
\end{table}

The cache stores transactions, receipts, and logs for recent blocks.
Reorg detection compares block hashes on each poll and invalidates from the
divergence point.

%------------------------------------------------------------------------------
\section{Updates \& Consistency (Delta-PIR)}
\label{sec:delta}
%------------------------------------------------------------------------------

\subsection{Delta Buffer}

The \texttt{DeltaBuffer} accumulates live state updates between epoch
rotations.

\paragraph{Key API.}
\begin{itemize}
  \item \texttt{push(row\_idx, diff)} --- append an update.
  \item \texttt{snapshot\_with\_epoch()} --- atomic read of epoch + entries
        (single lock).
  \item \texttt{drain\_for\_epoch(new\_epoch)} --- consume entries and
        advance epoch.
\end{itemize}

\paragraph{Consistent Scan.}
The \texttt{scan\_consistent} procedure ensures atomicity:

\begin{enumerate}
  \item Read snapshot epoch $e_1$ from \texttt{GlobalState}.
  \item Scan main matrix.
  \item Scan delta buffer (returns epoch + entries atomically).
  \item Verify delta epoch matches $e_1$; if not, retry.
  \item XOR matrix result with delta result.
\end{enumerate}

\paragraph{Backoff.}
Spin (attempts 0--9) $\to$ yield (10--49) $\to$ sleep (50+), max 1000
retries.

\subsection{Epoch Management}

\texttt{GlobalState} provides atomic epoch transitions via
\texttt{ArcSwap}:

\begin{itemize}
  \item \texttt{load()} / \texttt{store()} --- current
        \texttt{EpochSnapshot} (matrix + metadata).
  \item \texttt{load\_pending()} / \texttt{store\_pending()} --- pending
        \texttt{DeltaBuffer}.
  \item \texttt{try\_acquire\_manager()} --- single-writer lock for epoch
        advancement.
\end{itemize}

\paragraph{Merge.}
A background worker constructs $M_{e+1}$ using \textbf{Striped
Copy-on-Write}. Only memory stripes affected by updates are duplicated;
unmodified stripes are shared by reference (zero-copy). The global epoch
pointer advances atomically.

\subsection{Major Epochs (Seed Rotation)}

\begin{itemize}
  \item \textbf{Frequency:} Daily/Weekly.
  \item \textbf{Pipeline:} \texttt{reth-adapter} ETL $\to$ R2 upload $\to$
        server hot-swap.
  \item \textbf{Purpose:} Rotate Cuckoo seeds to prevent long-term
        statistical leakage.
\end{itemize}

%------------------------------------------------------------------------------
\section{Scan Engines}
\label{sec:scan}
%------------------------------------------------------------------------------

\subsection{GPU (CUDA)}

\begin{itemize}
  \item Fused ChaCha8-DPF$\oplus$XOR kernel on H100 VRAM (68.8\,GB).
  \item \textbf{Throughput:} 1,300\,GB/s (raw), 2,143\,GB/s
        (subtree-optimized).
  \item \textbf{Latency:} 32.1\,ms (subtree), 53\,ms (raw).
  \item 4KB-aligned paged storage, 128-bit vector loads.
\end{itemize}

\subsection{CPU (AVX-512)}

\begin{itemize}
  \item 8-row unrolled VAES with rayon parallelism.
  \item Portable fallback for non-AVX-512 hosts.
  \item Page DPF: chunked evaluation
        ($\texttt{OPTIMAL\_DPF\_CHUNK\_SIZE} = 65536$).
\end{itemize}

%------------------------------------------------------------------------------
\section{Security Analysis}
\label{sec:security}
%------------------------------------------------------------------------------

\subsection{Trust Model}

\textbf{2-Server Semi-Honest:} The two servers do not collude and follow the
protocol. Privacy is Information-Theoretic (IT-PIR). Integrity is trusted
(Privacy-Only mode).

\subsection{Privacy Theorem}

\begin{definition}[Server View]
For a query targeting account $\alpha$, server $b$'s view is:
\[
\mathsf{View}_b(\alpha) = \big( k_b^{(1)}, k_b^{(2)}, k_b^{(3)}, e, T \big)
\]
where $k_b^{(j)}$ are the three DPF key shares (for Cuckoo candidates),
$e$ is the requested epoch, and $T$ is timing metadata.
\end{definition}

\begin{theorem}[Query Privacy]
\label{thm:privacy}
Under the DPF security assumption~\cite{BGI15}, for any two targets
$\alpha, \beta \in [N]$:
\[
\mathsf{View}_b(\alpha) \approx_c \mathsf{View}_b(\beta)
\]
where $\approx_c$ denotes computational indistinguishability.
\end{theorem}

\begin{proof}
We show each component is indistinguishable:
\begin{enumerate}
  \item \textbf{DPF Keys:} By DPF security, each $k_b^{(j)}$ is
        computationally indistinguishable from a uniformly random string
        of equal length.
  \item \textbf{Timing $T$:} The scan executes exactly
        $N + \Delta_{\max}$ iterations regardless of $\alpha$.
        Memory access is sequential; no target-dependent branching occurs.
  \item \textbf{Access Pattern:} The client \emph{always} queries
        $\{h_1, h_2, h_3\}$, so the access pattern is deterministic.
\end{enumerate}
\end{proof}

\subsection{Leakage Assessment}

\begin{itemize}
  \item \textbf{Retry Oracle:} Eliminated. Consistency retries are handled
        server-side; clients may retry on transport errors, but retries do
        not depend on the query target.
  \item \textbf{Metadata:} The server learns only that the client is
        ``live'' (tracking the chain tip).
  \item \textbf{RPC Adapter:} Method routing minimizes upstream leakage.
        Private methods never touch the upstream RPC. Transactions relay
        through Flashbots Protect.
  \item \textbf{Collusion:} If both servers collude, they can XOR their DPF
        shares to recover the target:
        $\eval(k_0, x) \oplus \eval(k_1, x) = \mathbf{1}_{x=\alpha}$.
        The 2-server model assumes non-collusion.
\end{itemize}

\subsection{Verifiable PIR (Iceboxed)}

Trustless mode with sumcheck/binius proofs is designed but not in production.

%------------------------------------------------------------------------------
\section{Performance}
\label{sec:perf}
%------------------------------------------------------------------------------

\begin{table}[h]
\centering
\begin{tabular}{@{}lllll@{}}
\toprule
\textbf{Hardware} & \textbf{VRAM} & \textbf{Throughput} & \textbf{Latency}
& \textbf{Concurrent ($<$\,600\,ms)} \\
\midrule
NVIDIA B200 & 192\,GB & 2,510\,GB/s & 27.4\,ms & $\sim$21 \\
NVIDIA H200 & 141\,GB & 2,235\,GB/s & 30.8\,ms & $\sim$19 \\
NVIDIA H100 & 80\,GB  & 2,143\,GB/s & 32.1\,ms & $\sim$18 \\
\bottomrule
\end{tabular}
\caption{GPU scan performance (subtree-optimized kernel, 68.8\,GB matrix).
         H200/B200 extrapolated from synthetic benchmarks.}
\label{tab:perf}
\end{table}

%------------------------------------------------------------------------------
\section{Why ``Morphogenesis''}
\label{sec:name}
%------------------------------------------------------------------------------

The name honours Alan Turing's 1952 paper \emph{``The Chemical Basis of
Morphogenesis''}~\cite{Turing52}, in which two interacting chemicals---an
activator and an inhibitor---spontaneously create structured patterns from
random noise. Our 2-server protocol mirrors this precisely: each server
independently sees only pseudorandom noise (one ``activator'' share, one
``inhibitor'' share), yet when the client XORs the two responses, the noise
cancels everywhere \emph{except} at the target index, producing a single
structured ``spot'' of information from entropy---\emph{morpho-} (form)
+ \emph{-genesis} (creation).

%------------------------------------------------------------------------------
\section{Conclusion}
\label{sec:conclusion}
%------------------------------------------------------------------------------

\morph{} bridges the gap between theoretical PIR and systems reality. By
combining \textbf{Parallel Cuckoo Retrieval} (for privacy) with
\textbf{Epoch-Based Delta-PIR} (for consistency) and a full-featured
\textbf{RPC Adapter} (for wallet compatibility), we demonstrate private
Ethereum state access at 32.1~ms latency with $\sim$18 concurrent clients
on a single H100 GPU.

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
